{"remainingRequest":"D:\\Projeto Final\\Entrega\\Software\\Frontend\\node_modules\\babel-loader\\lib\\index.js!D:\\Projeto Final\\Entrega\\Software\\Frontend\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\Projeto Final\\Entrega\\Software\\Frontend\\src\\components\\pointerScroll.js","dependencies":[{"path":"D:\\Projeto Final\\Entrega\\Software\\Frontend\\src\\components\\pointerScroll.js","mtime":1617391304119},{"path":"D:\\Projeto Final\\Entrega\\Software\\Frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\Projeto Final\\Entrega\\Software\\Frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"D:\\Projeto Final\\Entrega\\Software\\Frontend\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["// flow scored from vue select thanks Jeff!\nexport default {\n  watch: {\n    pointer: function pointer() {\n      this.maybeAdjustScroll();\n    }\n  },\n  data: function data() {\n    return {\n      pointer: -1\n    };\n  },\n  methods: {\n    /**\n     * Adjust the scroll position of the dropdown list\n     * if the current pointer is outside of the\n     * overflow bounds.\n     * @returns {*}\n     */\n    maybeAdjustScroll: function maybeAdjustScroll() {\n      var pixelsToPointerTop = this.pixelsToPointerTop();\n      var pixelsToPointerBottom = this.pixelsToPointerBottom();\n\n      if (pixelsToPointerTop <= this.viewport().top) {\n        return this.scrollTo(pixelsToPointerTop);\n      } else if (pixelsToPointerBottom >= this.viewport().bottom) {\n        return this.scrollTo(this.viewport().top + this.pointerHeight());\n      }\n    },\n\n    /**\n     * The distance in pixels from the top of the dropdown\n     * list to the top of the current pointer element.\n     * @returns {number}\n     */\n    pixelsToPointerTop: function pixelsToPointerTop() {\n      var pixelsToPointerTop = 0;\n\n      if (!this.$refs.options) {\n        return 0;\n      }\n\n      for (var i = 0; i < this.pointer; i++) {\n        pixelsToPointerTop += this.$refs.options.children[i].offsetHeight;\n      }\n\n      return pixelsToPointerTop;\n    },\n\n    /**\n     * The distance in pixels from the top of the dropdown\n     * list to the bottom of the current pointer element.\n     * @returns {*}\n     */\n    pixelsToPointerBottom: function pixelsToPointerBottom() {\n      return this.pixelsToPointerTop() + this.pointerHeight();\n    },\n\n    /**\n     * The offsetHeight of the current pointer element.\n     * @returns {number}\n     */\n    pointerHeight: function pointerHeight() {\n      var element = this.$refs.options ? this.$refs.options.children[this.pointer] : false;\n      return element ? element.offsetHeight : 0;\n    },\n\n    /**\n     * The currently viewable portion of the options.\n     * @returns {{top: (string|*|number), bottom: *}}\n     */\n    viewport: function viewport() {\n      return {\n        top: this.$refs.options ? this.$refs.options.scrollTop : 0,\n        bottom: this.$refs.options ? this.$refs.options.offsetHeight + this.$refs.options.scrollTop : 0\n      };\n    },\n\n    /**\n     * Scroll the options to a given position.\n     * @param position\n     * @returns {*}\n     */\n    scrollTo: function scrollTo(position) {\n      return this.$refs.options ? this.$refs.options.scrollTop = position : null;\n    }\n  }\n};",{"version":3,"sources":["D:/Projeto Final/Entrega/Software/Frontend/src/components/pointerScroll.js"],"names":["watch","pointer","maybeAdjustScroll","data","methods","pixelsToPointerTop","pixelsToPointerBottom","viewport","top","scrollTo","bottom","pointerHeight","$refs","options","i","children","offsetHeight","element","scrollTop","position"],"mappings":"AAAA;AAEA,eAAgB;AACZA,EAAAA,KAAK,EAAE;AACLC,IAAAA,OADK,qBACK;AACR,WAAKC,iBAAL;AACD;AAHI,GADK;AAMZC,EAAAA,IANY,kBAML;AACH,WAAO;AACHF,MAAAA,OAAO,EAAE,CAAC;AADP,KAAP;AAGH,GAVW;AAWZG,EAAAA,OAAO,EAAE;AACP;AACN;AACA;AACA;AACA;AACA;AACMF,IAAAA,iBAPO,+BAOc;AACnB,UAAIG,kBAAkB,GAAG,KAAKA,kBAAL,EAAzB;AACA,UAAIC,qBAAqB,GAAG,KAAKA,qBAAL,EAA5B;;AAEA,UAAKD,kBAAkB,IAAI,KAAKE,QAAL,GAAgBC,GAA3C,EAAgD;AAC9C,eAAO,KAAKC,QAAL,CAAeJ,kBAAf,CAAP;AACD,OAFD,MAEO,IAAIC,qBAAqB,IAAI,KAAKC,QAAL,GAAgBG,MAA7C,EAAqD;AAC1D,eAAO,KAAKD,QAAL,CAAe,KAAKF,QAAL,GAAgBC,GAAhB,GAAsB,KAAKG,aAAL,EAArC,CAAP;AACD;AACF,KAhBM;;AAkBP;AACN;AACA;AACA;AACA;AACMN,IAAAA,kBAvBO,gCAuBc;AACnB,UAAIA,kBAAkB,GAAG,CAAzB;;AACA,UAAI,CAAC,KAAKO,KAAL,CAAWC,OAAhB,EAA0B;AACtB,eAAO,CAAP;AACH;;AAED,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKb,OAAzB,EAAkCa,CAAC,EAAnC,EAAuC;AACnCT,QAAAA,kBAAkB,IAAI,KAAKO,KAAL,CAAWC,OAAX,CAAmBE,QAAnB,CAA4BD,CAA5B,EAA+BE,YAArD;AACH;;AAED,aAAOX,kBAAP;AACD,KAlCM;;AAoCP;AACN;AACA;AACA;AACA;AACMC,IAAAA,qBAzCO,mCAyCiB;AACtB,aAAO,KAAKD,kBAAL,KAA4B,KAAKM,aAAL,EAAnC;AACD,KA3CM;;AA6CP;AACN;AACA;AACA;AACMA,IAAAA,aAjDO,2BAiDS;AACd,UAAIM,OAAO,GAAG,KAAKL,KAAL,CAAWC,OAAX,GAAqB,KAAKD,KAAL,CAAWC,OAAX,CAAmBE,QAAnB,CAA4B,KAAKd,OAAjC,CAArB,GAAiE,KAA/E;AACA,aAAOgB,OAAO,GAAGA,OAAO,CAACD,YAAX,GAA0B,CAAxC;AACD,KApDM;;AAsDP;AACN;AACA;AACA;AACMT,IAAAA,QA1DO,sBA0DI;AACT,aAAO;AACLC,QAAAA,GAAG,EAAE,KAAKI,KAAL,CAAWC,OAAX,GAAqB,KAAKD,KAAL,CAAWC,OAAX,CAAmBK,SAAxC,GAAmD,CADnD;AAELR,QAAAA,MAAM,EAAE,KAAKE,KAAL,CAAWC,OAAX,GAAqB,KAAKD,KAAL,CAAWC,OAAX,CAAmBG,YAAnB,GAAkC,KAAKJ,KAAL,CAAWC,OAAX,CAAmBK,SAA1E,GAAsF;AAFzF,OAAP;AAID,KA/DM;;AAiEP;AACN;AACA;AACA;AACA;AACMT,IAAAA,QAtEO,oBAsEEU,QAtEF,EAsEY;AACjB,aAAO,KAAKP,KAAL,CAAWC,OAAX,GAAqB,KAAKD,KAAL,CAAWC,OAAX,CAAmBK,SAAnB,GAA+BC,QAApD,GAA+D,IAAtE;AACD;AAxEM;AAXG,CAAhB","sourcesContent":["// flow scored from vue select thanks Jeff!\n\nexport default  {\n    watch: {\n      pointer() {\n        this.maybeAdjustScroll()\n      }\n    },\n    data() {\n        return {\n            pointer: -1\n        } \n    },\n    methods: {\n      /**\n       * Adjust the scroll position of the dropdown list\n       * if the current pointer is outside of the\n       * overflow bounds.\n       * @returns {*}\n       */\n      maybeAdjustScroll () {\n        let pixelsToPointerTop = this.pixelsToPointerTop()\n        let pixelsToPointerBottom = this.pixelsToPointerBottom()\n  \n        if ( pixelsToPointerTop <= this.viewport().top) {\n          return this.scrollTo( pixelsToPointerTop )\n        } else if (pixelsToPointerBottom >= this.viewport().bottom) {\n          return this.scrollTo( this.viewport().top + this.pointerHeight() )\n        }\n      },\n  \n      /**\n       * The distance in pixels from the top of the dropdown\n       * list to the top of the current pointer element.\n       * @returns {number}\n       */\n      pixelsToPointerTop() {\n        let pixelsToPointerTop = 0\n        if( !this.$refs.options ) {\n            return 0;\n        }\n\n        for (let i = 0; i < this.pointer; i++) {\n            pixelsToPointerTop += this.$refs.options.children[i].offsetHeight\n        }\n        \n        return pixelsToPointerTop\n      },\n  \n      /**\n       * The distance in pixels from the top of the dropdown\n       * list to the bottom of the current pointer element.\n       * @returns {*}\n       */\n      pixelsToPointerBottom() {\n        return this.pixelsToPointerTop() + this.pointerHeight()\n      },\n  \n      /**\n       * The offsetHeight of the current pointer element.\n       * @returns {number}\n       */\n      pointerHeight() {\n        let element = this.$refs.options ? this.$refs.options.children[this.pointer] : false\n        return element ? element.offsetHeight : 0\n      },\n  \n      /**\n       * The currently viewable portion of the options.\n       * @returns {{top: (string|*|number), bottom: *}}\n       */\n      viewport() {\n        return {\n          top: this.$refs.options ? this.$refs.options.scrollTop: 0,\n          bottom: this.$refs.options ? this.$refs.options.offsetHeight + this.$refs.options.scrollTop : 0\n        }\n      },\n  \n      /**\n       * Scroll the options to a given position.\n       * @param position\n       * @returns {*}\n       */\n      scrollTo(position) {\n        return this.$refs.options ? this.$refs.options.scrollTop = position : null\n      },\n    }\n  }\n"]}]}